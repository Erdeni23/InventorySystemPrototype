# Architecting Inventory Systems: A Case Study Collection

## 1. Зачем ?

   Этот репозиторий - не попытка создать единую универсальную инвентарную систему. Напротив, его центральная идея в том, что 'one-size-fits-all' инвентарь - это анти-паттерн. Успешная система всегда тесно вплетена в проект согласно конкретным нуждам конкретного проекта.

Здесь собрана выборка распространенных способов создания инвентарных систем, их технологии и аналоги в Unreal Engine 5. 
## 2. База

Для создания Любой хорошей системы вам нужно понимать плюсы и минусы доступных вам инструментов.

### 2.1 Struct (Структуры)

   Просто набор переменных в контейнере, основа для любых систем использующих на информацию.

### 2.2 Вес данных 

   Вы обязаны знать систему сохранений. Сохранение происходит в виде структур, поэтому очень важно иметь представление о весе данных, чтобы не перегружать сейв файл и не увеличивать нагрузку при сохранении/подгрузки.

**Очень важный момент**❗ 

Для каждой переменной существует два понятия **Размер(sizeof)** и **Требование к выравниванию(alignof) - Padding**. Sizeof это фактически занимаемый вес. Padding это особое требование к выравниванию членов и всей структуры. Простыми словами, процессор читает память не по одному байту, а целыми "порциями" (например, по 4 или 8 байт за раз). Чтобы переменная не оказалась "разрезана" между двумя такими порциями (что замедлило бы работу), компилятор автоматически добавляет невидимые байты-заполнители.

Эти "пустоты" и есть **Padding**. В результате структура занимает чуть больше места, но доступ к её данным происходит значительно быстрее.

На практике это означает следующее: старайтесь ставить самую тяжелую с точки зрения alignof переменную **В начало структуры** 

Например в коде ниже приведен пример того как Стоит располагать переменные. Это касается ВСЕХ структур и классов, не только в С++ но и в редакторе UE5 и блюпринтах.

```cpp
struct FInventoryItem 
{ 
    int64 ItemID; // 8 байт, выравнивание 8 
    int32 Quantity; // 4 байта, выравнивание 4 
    bool bIsEquipped; // 1 байт, выравнивание 1 
};
```

А теперь давайте посмотрим, что было бы, если бы мы расположили переменные в обратном порядке (от меньшей к большей):

```cpp
// Неправильный порядок, который создаёт много пустоты
struct FInventoryItem
{
    bool bIsEquipped;   // 1 байт
    // Компилятор добавит 7 байт пустоты (padding) здесь
    int64 ItemID;       // 8 байт
    int32 Quantity;     // 4 байта
    // Компилятор добавит 4 байта пустоты (padding) в конце
};
```

В таком случае sizeof(FInventoryItem_Bad) вернёт **24 байта** вместо **16**. Мы потеряли 8 байт на каждом предмете просто из-за неправильного порядка полей. 

Таблица основных для инвентаря данных

| Тип переменной                                | Size of(размер) в байтах | align of(выравнивание) в байтах |
| :-------------------------------------------- | :----------------------: | :-----------------------------: |
| bool                                          |            1             |                1                |
| int8/uint8                                    |            1             |                1                |
| int32/uint32/int/float                        |            4             |                4                |
| int64/uint64/long long/double                 |            8             |                8                |
| Сырые указатели/ TObjectPtr / TSubclassOf     |            8             |                8                |
| FName                                         |            12            |                4                |
| FString                                       |     16+Вес символов      |                8                |
| FText                                         |     24+Вес символов      |                8                |
| Слабые указатели TSoftObjectPtr/TSoftClassPtr |            24            |                8                |
